<!DOCTYPE html>
<meta charset="utf-8">
<head>
    <title>Am I getting faster?</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div class="title"></div>
    <div class="change"></div>
    <div id="option">
        <input name="updateButton" 
               type="button" 
               value="Update" 
               onclick="updateData()" />
    </div>
<!-- load the d3.js library -->    
<script src="d3.v3.js.min"></script>

<script>
// HELPER FUCTIONS
//Parse date
var parseDate = d3.time.format("%d-%b-%y").parse;

// Parse time
var parseTime = d3.time.format("%H:%M:%S").parse;
var parseShortTime = d3.time.format("%M:%S").parse;
// Parse the pace
function parsePace(pace){
  pace = d3.time.format("%M:%S").parse(pace);
  pace = +formatSecond(pace) + +formatMinute(pace)*60;
  return pace;
} 

// Getting seconds minutes and hours
var formatHour = d3.time.format("%H");
var formatMinute = d3.time.format("%M");
var formatSecond = d3.time.format("%S");
// Print the pace as MM:SS for tooltips and axis
var prettyPace = function(d) {
    var minutes = Math.floor(d/60);
    var seconds = +(d%60).toFixed(0);
    return(seconds == 60? (minutes+1) + ":00" : minutes + ":" + (seconds < 10 ? "0" : "") + seconds);
}
var prettyTime = function(d) {
    var minutes = Math.floor(d/60);
    var seconds = +(d%60).toFixed(0);
    return(seconds == 60? (minutes+1) + ":00" : minutes + ":" + (seconds < 10 ? "0" : "") + seconds);
}
// Add the title to the chart
function plotTitle(formattedSlope, formatSlope, m, b) {
    document.getElementsByClassName("title")[0].innerHTML = "KP Pace Chart";
    document.getElementsByClassName("change")[0].innerHTML = "y= " + m + "x + " + b + "Formatted slope: " + formattedSlope;
}
// Define the line
var valueline = d3.svg.line()
    .x(function(d) { return x(d.date); })
    .y(function(d) { return y(d.distance); });


var colors=["#000","#3A80E5"];
// SETUP FUNCTIONS
// Set the dimensions of the canvas / graph
var margin = {top: 30, right: 20, bottom: 30, left: 50},
    width = 800 - margin.left - margin.right,
    height = 400 - margin.top - margin.bottom,
    padding = 30,
    legendElementSize=10,
    legendPadding=10,
    legendTextPadding=20;
// Set the ranges
var x = d3.time.scale().range([0,width]);
var y = d3.scale.linear().range([height, 0]);

var regX = d3.scale.linear().range([0,width]);
// Define the axes

var xAxis = d3.svg.axis().scale(x)
    .orient("bottom").ticks(10)
    .tickFormat(d3.time.format("%b-%y"));

var yAxis = d3.svg.axis().scale(y)
    .orient("left").ticks(8)
    // Make ticks as wide as the graph
    .tickSize(-width)
    // And represent them in time form
    .tickFormat ( function(d) {
      var minutes = Math.floor(d/60);
      var seconds = +(d%60).toFixed(0);
      return(seconds == 60? (minutes+1) + ":00" : minutes + ":" + (seconds < 10 ? "0" : "") + seconds);
    });

var yAxisDist = d3.svg.axis().scale(y)
    .orient("left").ticks(8)
    // Make ticks as wide as the graph
    .tickSize(-width);

// Adds the svg canvas
var svg = d3.select("body")
    .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom+20)
    .append("g")
        .attr("transform", 
              "translate(" + margin.left + "," + margin.top + ")");
// Add in the tooltips
var tooltip = d3.select("body").append("div")
    .attr("class", "tooltip")
    .style("opacity", 0);
// Get the data
function distanceGraph(data) {

    // Scale the range of the data again 
    x.domain(d3.extent(data, function(d) { return d.date; }));
    y.domain([0, d3.max(data, function(d) { return d.distance+3; })]);

        // Add the X Axis
    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);

    svg.append("text")
      .attr("class", "yaxisLabel")
        .attr("transform", "rotate(-90)")
      .attr("y", 0 - margin.left)
      .attr("x",0 - (height / 2))
      .attr("dy", "1em")
      .style("text-anchor", "middle")
      .text("Distance (Miles)");    
    // Add the Y Axis
    svg.append("g")
        .attr("class", "y axis")
        .call(yAxisDist)
        .selectAll(".tick line").attr("stroke", "#666").attr("stroke-dasharray", "3,4");
    
    // Scatterplot of distance
    svg.selectAll("dot") 
        .attr("class","dot")   
        .data(data)         
        .enter().append("circle")                               
        .attr("r", 4)     
        .attr("fill", "#ccc")  
        // Use domain functions to plot x/y coordinates of data
        .attr("cx", function(d) { return x(d.date); })       
        .attr("cy", function(d) { return y(d.distance); })
        // Tooltip 
        .on("mouseover", function(d) {      
            tooltip.transition().style("opacity", .9);      
            tooltip.html("Distance: " + d.distance)
                   .style("left", (d3.event.pageX + 5) + "px")
                   .style("top", (d3.event.pageY - 18) + "px");
            })                  
        .on("mouseout", function(d) {       
            tooltip.transition().style("opacity", 0);   
        });

    svg.append("line")
      .attr("class", "regression")
      .attr("x1", x(parseDate("5-Apr-17")))
      .attr("y1", height)
      .attr("x2", x(parseDate("5-Apr-17")))
      .attr("y2", 0);
    svg.append("line")
      .attr("class", "regression")
      .attr("x1", x(parseDate("1-Oct-17")))
      .attr("y1", height)
      .attr("x2", x(parseDate("1-Oct-17")))
      .attr("y2", 0);
}

d3.csv("pretty-pace.csv", function(error, data) {
    data.forEach(function(d) {
        // Make the numbers numbers!
        d.number = +d.number;
        d.distance = +d.distance;
        
        // Parse date
        d.date = parseDate(d.date);

        // "Durations" (time and pace) will be represented in total seconds
        // If time includes hours, we'll need to parse it differently
        if (d.time.length > 5) {
          d.time = parseTime(d.time);          
          d.time = +formatHour(d.time)*3600 + +formatSecond(d.time) + +formatMinute(d.time)*60;
        // Otherwise, just consider mins and seconds
        } else {
          d.time = parseShortTime(d.time);
          d.time = +formatSecond(d.time) + +formatMinute(d.time)*60;
        }

        // Turn pace into d3 time format
        // Get minutes and seconds and calculate total seconds
        d.pace = parsePace(d.pace);

        // console.log("Date: " + d.date + "\nDistance: " + d.distance + "\nTime: " + d.time + "\nPace: " + d.pace );
    });

    distanceGraph(data);



    // LEGEND
    /*
    var legend = svg.selectAll(".legend").data([0].concat(function(d) { return d; }));
      legend.enter().append("g").attr("class", "legend");
      // Modified the x and y to make the legend vertical
      legend.append("rect")
        .attr("x", width-90)
        .attr("y", function(d, i) { return (legendElementSize * i) + legendPadding; })
        .attr("width", legendElementSize)
        .attr("height", legendElementSize)
       // .attr("transform",function (d,i) {return "translate(0," +i + 20 + ")"})
        .style("fill", function(d, i) { return colors[i]; });
      legend.append("text")
        .attr("class", "sans")
        .text(function(d, i) { 
            var legend = ["Pace","Regression"];
            return legend[i]})
        .attr("x", width-70)
        .attr("y", function(d, i) { return (legendElementSize * i)+legendTextPadding; })
      legend.exit().remove();
      */
});
</script>
</body>